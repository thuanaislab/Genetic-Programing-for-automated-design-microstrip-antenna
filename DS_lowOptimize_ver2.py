# thuan.bb.hust@gmail.com - 2019
import Helper as hp 
import numpy as np
import os
from genscript import genscript
import copy 
import random
import matplotlib.pyplot as plt
import helpRunning as hrun 
import shutil
import sys
import InitPopMethods as initpop
import str2tree


import initGlobal as init
import update_state as us 
lowinit = init.lowlevel()
ant = init.AnT()
inGP = init.GP() # get the essential parameters of GP process from initGlobal.py file. note: this's global parameter.
if init.Re_trainning:
	ant = init.AnT()
	Sub = init.Sub()
	L   = init.L()
	U   = init.U()
	lowinit = init.lowlevel()
	GP = init.GP()
	# path = us.load_temporary_path()
	us.update_all_saved_parameters(ant, Sub, L, U, GP, lowinit)
else:
	us.update_path_low(ant,lowinit)




class state:
	pass 
class temppp:
	pass


def lowlevel_optimizer(ind,state,pop_num):
	# the inputs: - IND  individual
	# 			  - STATE
	#			  - POP_NUM the specified ID of current individual which be optimized in here.



	anpha = lowinit.anpha
	saved_tree = [] # save all of the current tree generated by all of the directions
	for i in range(lowinit.number_direction):
		saved_tree.append([])
	state.lowlevel = True
	global_name = lowinit.tmpDir + ant.Antenna_Name + 'lowlevel_gen_'
	global_tabname = lowinit.tmpTab + ant.Antenna_Name + '_gen_'
	print('running low-level optimizer for generation ',state.gen,'population ', pop_num)
	chromosome, subtree_chrom, IDlist = hp.getChrom(ind) # get chromosome from tree and other atributes.

	num = len(chromosome) # number of values will be optimized.

	# create randomly the trainning data for ANN.

	y = [] # to save all of the fitness of each direction.
	for i in range(lowinit.number_direction):
		y.append([])
	state.current_low_fitness = y

	fitness = ind.fitness  # save original chromosome fitness.
	return_loss = []
	return_loss.append(ind.ReturnLoss) # save original return loss variable.
	for i in range(lowinit.number_direction):
		return_loss.append([])

	X_training = np.zeros((lowinit.number_direction,num)) # X_training in this case used for direct search method.

	d = X_training # init the matrix of the directions.

	current_chromosome = np.zeros(num)

	for i in range(num): # save original chromosome, where this point is the start point as well as the x0 point.
		current_chromosome[i] = chromosome[i]

	for i in range(lowinit.number_direction): # create the matrix of the direction. 
		for ii in range(num):
			d[i][ii] = round(random.uniform(-1,1),4) # X_training in this case is the matrix direction.
	#print(X_training)
	########################################################################################################################
	########################################################################################################################
	for k in range(lowinit.number_search_step):
		state.lowlevel_k = k 
		# now update the x_k follow each of direction.
		for i in range(lowinit.number_direction):
			for ii in range(num):
				X_training[i][ii] = current_chromosome[ii] + anpha*d[i][ii]
				if X_training[i][ii] > 1:     # need be in range [-1,1]
					X_training[i][ii] = 1
				if X_training[i][ii] < -1:
					X_training[i][ii] == -1
					

		# generate all of the scripts.
		print('generating ',lowinit.number_direction, ' scripts in low lelvel optimizer in generation ',state.gen)


		#tree_temp = hp.insert_chrom(ind.tree,X_training[2,:],subtree_chrom, IDlist)
		for i in range(lowinit.number_direction):
			tree = hp.insert_chrom(ind.tree,X_training[i,:],subtree_chrom, IDlist)
			#if i != 2:
			#	if tree == tree_temp:
			#		raise 
			#pop[i].tree.childs[1].valueofnode.plot()
			[Substrate,polygons,centroid,poly_list,poly_list_type] = hp.get_all_para_for_hfss(tree) # get necessary parameters for genscript function.
			name = global_name + str(state.gen)+ '_pop_' + str(state.population_num) + '_step_k' + str(k) +'_d_' + str(i) # name of directory would
																			# be used to save .vbs and .hfss file.
			tabname = global_tabname + str(state.gen)+ '_pop_' + str(state.population_num) + '_step_k' + str(k) + '_d_' + str(i) # name of directory
																				# would be used to save .tab file. 
			temppp.tree = tree
			temppp.nodelist = ind.nodelist
			temp,_,_ = hp.getChrom(temppp)
			print(X_training[i,:])
			print(".....")
			print(temp)
			for iiii in range(len(X_training[i,:])):
				if not (X_training[i,iiii] == temp[iiii]): # this part is to test the insert and getchrom function.
					raise 
			genscript(Substrate,polygons,centroid,name + '.vbs',tabname,name + '.hfss',poly_list,poly_list_type)
			f = open(name + '.txt','w')
			f.write(hp.tree2str(tree))
			f.close()
			saved_tree[i] = tree
			del tree
			del Substrate
			del polygons
			del centroid

		#raise ValueError("Finished testing")
		#######
		#  running all of the scripts.
		nameDir = global_name + str(state.gen)+ '_pop_' + str(state.population_num) + '_step_k' + str(k) +'_d_'  # file name direction of the vbs file.
		hrun.RunPopScript(lowinit.number_direction,nameDir,0,len(init.PCnames),state)

		# getting the fitness of each 
		for i in range(lowinit.number_direction):
			spec_nameDir_tab = global_tabname + str(state.gen) + '_pop_' + str(state.population_num) + '_step_k' + str(k) + '_d_' + str(i) + '.tab'
			[m,n,p,q] = hrun.assignFitness(spec_nameDir_tab,state.gen)
			print('i ',i, '___',m)
			[y[i],return_loss[i]] = [m,n]
			if m < inGP.desired_fitness:
				shutil.copy2(global_name + str(state.gen)+ '_pop_' + str(state.population_num) + '_step_k' + str(k) +'_d_' + str(i) +  '.vbs', ant.resultsDir)
				shutil.copy2(spec_nameDir_tab, ant.resultsDir)
				shutil.copy2(global_name + str(state.gen)+ '_pop_' + str(state.population_num) + '_step_k' + str(k) +'_d_' + str(i) + '.txt', ant.resultsDir)
				#hp.drawtree(pop[i].tree,ant.resultsDir + '_gen_' + str(gen) + '_pop_' + str(i))
				f = open(ant.resultsDir + 'lowlevel_gen_' + str(state.gen)+ '_pop_' + str(state.population_num) + '_step_k' + str(k) +'_d_' + str(i) + '.txt','w')
				#f.write(hp.tree2str(saved_tree[i]))
				#f.write('#')
				f.write('fitness: ' + str(m))
				f.write('#')
				if p:
					f.write("_____exist best fitness")
					if q:
						f.write("___ that is better than overcome_desired")
				#f.write('time: ' + str((time.time() - first_time)/60))
				f.close()

		### 
		fitness_k = min(y)
		index = y.index(fitness_k)
		if fitness_k < fitness:
			for i in range(num):
				current_chromosome[i] = X_training[index][i]
			fitness = fitness_k
		else:
			anpha = anpha*lowinit.shrink   # shrink the anpha maybe because the stepsize is a little big.
		

	# np.savetxt('C:\\Opt_files\\lowlevel\\y.txt',y,delimiter = ',')
	# np.savetxt('C:\\Opt_files\\lowlevel\\X.txt',X_training,delimiter = ',')
	ind.fitness = fitness
	ind.tree = hp.insert_chrom(ind.tree,current_chromosome,subtree_chrom, IDlist)
	state.lowlevel = False
	#del saved_tree

	return ind

#str_tree = str2tree.load_str_tree('C:/Opt_files/GP2019_03_21_11h44m55s/temp/MPA_gen_10_pop_0.txt')
str_tree = sys.argv[1]
fitness = float(sys.argv[2])   # the fitness of the this tree.
state.gen = int(sys.argv[3])   # the current generation number of this tree.
state.population_num = int(sys.argv[4]) # the current population number of this tree.
state.best_hisFitness_inlow = float(sys.argv[5]) # state.best_hisFitness[-1]
state.curFitness = sys.argv[6]						 
temp_tree = str2tree.str2tree(str_tree,0,1,0,None)
temp_tree = str2tree.update_tree(temp_tree)
#hp.drawtree(temp_tree)
ind = initpop.restruct_ind(temp_tree,0)
ind.fitness = fitness
newind = lowlevel_optimizer(ind,state, state.population_num)
path = ant.tmpDir + ant.Antenna_Name + '_gen_' + str(state.gen) + '_pop_' + str(state.population_num)
f = open(path + '.txt','w')
f.write(hp.tree2str(newind.tree))
f.close()


